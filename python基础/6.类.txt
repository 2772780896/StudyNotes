'''
创建类(class)
 class 类名(父类名):
   属性(赋值语句)
   方法(函数)
  父类：创建一个类时这个类继承的类，没有继承时默认为object，object为被所有类所继承的类，为类提供模板

创建对象(object)
 对象名=类名()

对象方法
 在类中创建对象方法
  def object_f1(self,x): return
 调用对象方法
  对象名.方法名(参数)  在类的框架内，通过对象名来调用类中的对象方法
  一个对象方法可以被另一个对象方法调用
   def object_f2(self, x):
       self.object_f1(x)
  self代表类假设的创建的一个对象
  类名.方法名(参数)  在类的框架外，可通过类名来调用类中的对象方法

类方法
 创建类方法
  创建一个类方法需要用@classmethod来声明
   @classmethod
   def class_print_number(cls,x): return
  cls在类这个框架中代表类自己，即类名
 调用类方法
  在类的框架内或外，通过类名或对象名来调用类中的类方法
   对象名/类名.方法名(参数)

静态方法
 创建静态方法
  创建一个静态方法需要用@staticmethod来声明
   @staticmethod
   def static_print_number(x): return
  静态方法中没有参数self或cls，所以静态方法不可通过self来调用类的框架中的对象属性和对象方法或其它类的对象方法
 调用静态方法
  在类的框架内或外，通过对象名或类名来调用类中的静态方法
   对象名/类名.方法名(参数)

类属性
 创建类属性
  class_attribute1=1
  当对象被创建之后，类属性被赋予给对象，成为对象属性
 调用类属性
  类名/对象名.属性名
  类属性可以被任意调用
  即使是在类内部，调用类属性时也需要使用上述格式
  在类内部的对象方法中，用 self.属性名 调用属性时，相当于使用了 nonlocal self.属性名 的形式，使得 self.属性名 就是之前被创建的类属性的引用调用

对象属性
 创建对象属性
  def __init__(self,x):
      self.object_attribute1 = x
  __init__是一个构造方法，在使用类创建对象时被自动调用，用于赋予对象初始值
 调用对象属性
  对象名=类名(对象属性参数)  在创建对象时将参数传递给 __init__ 函数，此时对对象属性赋值
  对象名.对象属性名  对象属性只能被对象属性和对象方法调用

私有属性
 私有属性无法通过原属性名被类的外部直接访问
 创建私有属性
  在属性名前加__创建私有属性
   __private_attribute=1
 调用私有属性
  self.__private_attribute
  私有属性的属性名在外部可通过 类名/对象名._类名/对象名__私有属性名 来调用

动态操作，在类或对象创建完成后在其外部对其内部进行的操作
 动态为对象添加属性
  对象名.属性名 = 值
  当属性名存在时，会修改属性的值。当属性名不存在时，会创建属性并赋值
 动态为对象添加方法
  def 方法名(参数): return
  对象名.方法名 = 方法名
 动态为类添加属性，并影响对象
  类名.属性名 = 值
 动态为类添加对象方法，并影响对象
  def 方法名(self，参数): return
  类名.方法名 = 方法名

继承
 class 继承者(被继承者)
 继承者(subclass)拥有被继承者(superclass)的所有属性和方法
 super()  返回一个父类的对象
  当需要执行父类的方法时，用 super().父类方法名(参数)

魔术方法
 以 __方法名__ 为名的方法

 __slots__=(限制的属性名)  限制对象中出现的属性名只能为被__slots__指定的属性名

 __new__()  在对象创建时被自动调用，被用于在堆区开辟一片内存空间给对象使用
 单例，一个类只能有一个对象存在
  可通过对 __new__ 进行重新定义，在创建对象时，如果该类已经有了一个对象，那么新对象将不会创建新的内存空间，而是与已有对象使用同一个内存空间，以实现单例

 __str__()  在对象被print()执行时调用，该函数的返回值即为 print(对象) 的返回值

 类名.__bases__  返回一个元组，这个元组包含类的所有父类
  print(number_sub.__bases__)  返回 (<class '__main__.number'>,)
  通过修改__bases__属性使得动态修改类的父类
   type('类型名',(类型的父类名,),{'类型中的属性名': 值})  用于创建一个新的类型，返回值为 <class '__main__.类型名'>
                                                  也就是说，类型和类是同一个东西，一个类就是一种类型
   类名.__bases__ = 类名.__bases__ + (type生成的类型,)  在原类型的父类元组中添加一个新的元组，实现元组合并，并将新类作为父类元组中一员

 __call__()  控制对象执行时结果，即 对象()=对象.__call__()，
  实现装饰器
   class decorator():
      def __init__(self, decorated_func):
          self.decorated_func=decorated_func
      def __call__(self):
          对 self.decorated_func() 进行的操作
   此时执行 被装饰函数=装饰器(被装饰函数) 相当于创建了名为被装饰函数的对象
  当需要给装饰器传参时，即用@装饰器(参数)时
   class decorator():
      def __init__(self, decorated_func):
          self.参数=参数
      def __call__(self，参数):
          对 self.decorated_func(参数) 进行的操作

内存回收机制
 当对象不被引用时，释放这个对象，将这个对象所占用的空间腾出
 想法；
  控制中心遍历一遍代码，得到每一条代码所占用的内存，当代码被写入或删除时，记录对应的内存变化
 实际：
  在以上的基础上引入计数器机制，当一个内存被一条代码所指向时，在这个内存专属的计数器上加一，当一条指向这个内存的
  代码被删除时，在这个计数器上减一，当计数器为零时释放这个内存
 实际相比于想象的优点：
  计数器保障了误删不会出现，即当前面的代码还在使用一个内存空间时，如果删除的代码也指向了这个内存空间，那么此时控
  制中心需要再遍历一遍代码才能知道是否还有代码还在使用这个内存空间，这个操作过于繁琐
'''