'''
安装ts
 npm i -g typescript
编译ts文件
 tsc 文件名.ts  会在同级生成 文件名.js 文件，后可用node执行js文件
ts-node包，用于简化ts文件运行
 npm i -g ts-node
 ts-node 文件名.ts  将ts编译为js后执行，不会在同级生成对应js文件

基本类型
 类型注解
  let 变量名: 类型 = 值  在进行类型注解后，如果给该变量赋一个不同类型的值，就会报错
 基本类型写法
  number, string, boolean, null, undefined
 联合类型
  (基本类型名1 | 基本类型名2)  表示联合类型，数据类型即可为基本类型名1，也可为基本类型名2
 自定义类型
  type 驼峰式类型名 = 类型  自定义一个类型，该类型由其他类型组成，用法同其他类型的用法

字面量类型
 字符串，数字，对象  当一个变量被指定为字面量类型后，该变量的值必须与其字面量类型相同

any类型
 any  被指定后，不会对值的类型进行任何约束

数组类型写法
 基本类型名[]  表示数组类型，并且数组中的数据类型只能为指定的基本类型
 或不常用的写法 Array<基本类型名>  用法同上
元组类型写法
 [基本类型名1, 基本类型名2]  表示元组类型，类似数组，只不过指定数组中的元素个数和每一项的数据类型

函数类型
 类型注解
  function 函数名(参数1: 类型1, 参数2...): 类型2 {} 或箭头函数 const 函数名 = (参数1: 类型1, 参数2...): 类型2 => {}
   类型1用于指定参数的类型，类型2用于指定返回值的类型
  或 const 函数名: (参数1: 类型1, 参数2...) => 类型2 = (参数1, 参数2...) => {}
   类型1用于指定参数的类型，类型2用于指定返回值的类型，这种方式只可在箭头函数中使用
  函数特有类型
   void  当函数没有返回值时，返回值类型可被指定为void
  可选参数
   function 函数名(参数1, 参数2?) {}  在参数2后加?表示参数2为可选参数，在调用函数时可传参也可不传。可选参数必须写在必选参数之后

对象类型
 类型注解
  let 对象名: {键名1: 类型1; 键名2: 类型2...} = {键名1: 值1, 键名2: 值2}}
  当对象中的元素为一个函数时
   let 对象名: {函数键名(参数: 类型1): 类型2 } = {函数键名(参数){}}
 可选键
  let 对象名: {键名1: 类型1; 键名2?: 类型2...} = {键名1: 值1, 键名2: 值2,}}  键名2可有可无
 接口
  interface 驼峰式接口名 {键名1: 类型1; 键名2: 类型2...}  创建一个自定义的对象类型
  let 对象名: 接口名 = {键名1: 值1, 键名2: 值2}  对对象使用该自定义类型
  自定义接口也可通过自定义类型实现，但接口只可用于对象
  接口继承
   interface 接口类型名1 {键名1: 类型1}
   interface 接口类型名2 extends 接口类型名1 {键名2: 类型2}  相当于 interface 接口类型名2 {键名1: 类型1; 键名2: 类型2}
  交叉
   interface 接口类型名1 {键名1: 类型1}; interface 接口类型名2 {键名2: 类型2}
   type 类型名3 = 接口类型名1 & 接口类型名2  通过交叉运算符，类型3获得两个接口中的所有属性
  冲突处理
   当父接口中存在一个键，继承自父接口的子接口中如果也存在同名键，此时报错
   交叉的两个接口中如果存在同名键，那么类型3中有 同名键:类型1 | 类型2

索引签名
 对象索引签名
  interface 接口名 { [key: string]: 类型1 }
   在js中，对象的键一定会是string类型，通过 [key: string] 声明要创建的对象的键的类型一定会是string，也就是说要创建的一定是一个对象，通过 : 类型2 指定键的值的类型
  let 对象名: 接口名 { 键1: 值1, 键2: 值2... }  对象名中可创建任意多的键值对，只需分别符合 接口名 指定的类型
 数组索引签名
  interface 接口名 { [key: number]: 类型1 }
   在js中，键的类型为数字的对象会成为数组
  let 数组名: 接口名 = [符合类型1的值...]  用[]创建数组，即为创建了key为number类型且自增的对象

枚举
 enum 驼峰式枚举名 { 枚举元素1, 枚举元素2... }  创建一个枚举类型，可通过 枚举名.枚举元素 来得到对应元素的值，默认枚举元素1的值为0，枚举元素2的值为1...
  当变量被指定该类型后，其值必须与其中一个枚举元素的值相同
 enum 驼峰式枚举名 { 枚举元素1 = 值1, 枚举元素2 = 值2... }  手动设置枚举元素的值
 枚举在被编译为js后，会生成一个名为 枚举名 的对象，将枚举元素名作为对象中元素的键，值作为值，依然可被调用。所以枚举的开销更大

class类型
 class 类名 {}
 const 实例名 = new 类名()  此时根据类型推论，实例的类型被声明为 类名 的类型
可见性修饰符
 class 类名 { 可见性修饰符 变量名 = 值 }  可见性修饰符可对类中的属性或方法使用
 public  为默认修饰符，表示可在任何地方被访问
 protected  表示只可在类或子类的内部被访问，在实例中无法访问
 private  表示只可在类的内部被访问，在子类或实例中无法被访问
实现接口
 interface 驼峰式类型名 {键名1: 类型1; 键名2: 类型2...}
 class 类名 implements 接口名 {变量名1=值1; 变量名2=值2...}  类中必须创建与接口中的所有键名对应的变量名，其值符合对应的数据类型

类型推论
 let 变量名 = 值  省略对变量名的类型的声明，但根据值的数据类型，自动声明变量名的类型
 function 函数名(参数: 类型) { return 参数 }  自动声明返回值的类型
类型断言
 let 变量名 = 值 as 类型  手动声明变量名的数据类型

typeof
 let 变量名1: 类型1 = 值1
 let 变量名2: typeof 变量名1 = 值2  声明变量名2的类型和变量名1的类型相同

类型兼容性
 ts采用的是结构化类型系统，即如果两个类型的结构相同，即使他们的名称不同，那么其中一个类型的值依然可以被另一个类型的变量接收
 同时，如果一个类型1中的一些内容是类型2中的全部内容，那么类型1的值依然可以被类型2的变量接收，多出的部分不会被接收

泛型  通过将类型作为参数传入，动态的获取传入的类型
 泛型函数
  function 函数名<类型参数>(参数: 类型参数): 类型参数 { return 参数 }
   在创建函数时通过 <类型参数> 接收一个传入的类型，通过 类型参数 来调用
   类型参数可以有多个，用 , 间隔
  const 变量名 = 函数名<类型>(参数)  在调用函数时，通过 函数名<类型> 的方式进行类型的传参
 类型推断
  在调用泛型函数时，可以省略 <类型> ，此时会根据 参数: 类型参数 推断出 <类型参数> 的类型
 泛型约束
  interface 接口名 { 键名: 类型1 }
  function 函数名<类型参数 extends 接口名>(参数: 类型参数): 类型参数 { return 参数.键名 }
   extend用于约束传入的类型参数，使其必须有 键名 这一属性，用于保障其后对 参数.键名 的调用一定存在
 泛型接口
  interface 接口名<类型参数> { 键名: 类型参数 }  创建泛型接口
  let 对象名: 接口名<类型> = {键名: 值}  调用泛型接口，调用时传入一个类型
 泛型类
  class 类名<类型参数>{}  创建泛型类
  const 变量名 = new 类名<类型>()  调用类创建实例时，传入一个类型
 泛型工具
  Partial
   interface 接口名1 {键名1: 类型1; 键名2: 类型2...}
   type 接口名2 = Partial<接口名1>
    将接口名1中的每一项设为可选，生成一个新的类型，并且不对接口名1产生影响，将该新值赋值给接口名2
    相当于 type 接口名2 = {键名1?: 类型1; 键名2?: 类型2...}
  Readonly
   interface 接口名1 {键名1: 类型1; 键名2: 类型2...}
   type 接口名2 = Partial<接口名1>
    将接口名1中的每一项设为只读，无法通过 接口名2的实例.键名1 = 新值 来修改其中的元素的值
  Pick
   interface 接口名1 {键名1: 类型1; 键名2: 类型2, 键名3: 类型3}
   type 接口名2 = Partial<接口名1, '键名1'|'键名2'>
    选择接口名中的特定项，新生成的类型中只会包含被指定的项
    相当于 type 接口名2 = {键名1: 类型1; 键名2: 类型2}
  Record
   type 类型名 =  Record<'键名1' | '键名2', 类型>
    第一个参数指定 类型名 中的键名，第二个参数指定所有键名对应的类型
    相当于 type 类型名 = {键名1: 类型; 键名2: 类型}

映射
 in
  type 类型名1 = 字符串1 | 字符串2  类型名1为两个字面量类型的联合类型
  type 类型名2 = { [Key in 类型名1]: 类型 }
   in 会遍历获取 字符串1|字符串2 中的每一项，依次返回对应的 字符串 作为Key的值
   相当于 type 类型名2 = {字符串1:类型; 字符串2:类型}
 keyof
  type 类型名1 = { 键名1: 类型1, 键名2: 类型2 }
  type 类型名2 = { [Key in keyof 类型名1]: 类型3 }
   keyof会获取一个对象类型中的每一个键名，返回 '键名1'|'键名2'
   相当于 type 类型名2 = {键名1:类型3; 键名2:类型3}
 索引查询
  单查询
   type 类型名1 = { 键名1: 类型1, 键名2: 类型2 }
   type 类型名2 = { [Key in keyof 类型名1]: 类型名1[Key] }
    类型名1[Key] 获取类型名1中对应键名的类型
    相当于 type 类型名2 = {键名1:类型1; 键名2:类型2}
  联合查询
   type 类型名1 = { 键名1: 类型1, 键名2: 类型2 }
   type 类型名2 = { [Key in keyof 类型名1]: 类型名1[keyof 类型名1] }
    类型名1[keyof 类型名1] 即 类型名1[键名1|键名2]，返回 键名1的类型|键名2的类型
    相当于 type 类型名2 = {键名1:类型1|类型2; 键名2:类型1|类型2}

类型声明文件
 以 .d.ts 为后缀的文件，与 .ts文件不同的是，类型声明文件不包含可执行js代码，不会被编译为js文件，仅声明类型信息
 在安装ts后，安装了对js中常用方法的类型声明文件，使得通过 ctrl 查看方法信息时，可以查看对应类型信息
 外部包的类型声明文件
  包中自带 .d.ts 的类型声明文件，并在 package.json 中有 "typings": ".d.ts文件"
  当包没有自带类型声明文件时，可通过 npm i --save-dev @types/对应包名 来安装对应包的类型声明文件
 自用的类型声明文件
  当多个ts使用相同的类型时，创建一个类型声明文件给其共同使用
   导出导入方式同js中的导出导入
  为已有的js文件提供类型声明文件进行类型声明
   创建与js文件同名的 .d.ts 文件
   declare
    declare let 变量名: 类型  在声明变量的类型时，通过declare表明时为了js中的变量进行类型声明，而不是创建一个声明了类型的新的变量
     在用 type, interface 等ts特有关键字时，可省略declare
'''